1) Renomeie app/templates.py para app/template_helpers.py para não conflitar com a pasta templates. Atualize todos os imports que referenciam app.templates para app.template_helpers.\n> \n> 2) Crie um helper central de templates em app/template_helpers.py:\n> python\n> from fastapi.templating import Jinja2Templates\n> from app.services.i18n import get_translator\n> \n> templates = Jinja2Templates(directory=\"templates\")\n> \n> # registrar função t() global no Jinja\n> def install_i18n(env):\n> def t(key: str, **kwargs):\n> # a locale virá de um middleware/cookie; por padrão pt\n> from fastapi import Request\n> # fallback simples: pt\n> def _t(request: Request, k: str):\n> locale = request.cookies.get(\"locale\", \"pt\")\n> return get_translator(locale)(k, **kwargs)\n> return _t\n> env.globals[\"t\"] = lambda key, request=None, **kw: get_translator((request.cookies.get(\"locale\") if request else \"pt\") or \"pt\")(key, **kw))\n> \n> install_i18n(templates.env)\n> \n> (Se já houver utilitário i18n, apenas garanta que templates.env.globals['t'] exista). \n> \n> 3) Em TODOS os routers que renderizam HTML, use o MESMO templates desse helper:\n> python\n> from fastapi import APIRouter, Request\n> from fastapi.responses import HTMLResponse\n> from app.template_helpers import templates\n> \n> router = APIRouter()\n> \n> @router.get(\"/about\", response_class=HTMLResponse)\n> async def about(request: Request):\n> return templates.TemplateResponse(\"about.html\", {\"request\": request})\n> \n> Sempre passe {\"request\": request} no contexto.\n> \n> 4) Inclua todos os routers no app/main.py (se ainda não estiver):\n> python\n> from app.routers import main as main_router, auth as auth_router, tools as tools_router, billing as billing_router, admin as admin_router\n> app.include_router(main_router.router)\n> app.include_router(auth_router.router)\n> app.include_router(tools_router.router)\n> app.include_router(billing_router.router)\n> app.include_router(admin_router.router)\n> \n> \n> 5) Em app/routers/tools.py, garanta as rotas GET das páginas (além dos POST), com o mesmo templates e sempre passando request:\n> python\n> @router.get(\"/tools/merge\", response_class=HTMLResponse)\n> async def tool_merge(request: Request):\n> return templates.TemplateResponse(\"tools/merge.html\", {\"request\": request})\n> \n> @router.get(\"/tools/split\", response_class=HTMLResponse)\n> async def tool_split(request: Request):\n> return templates.TemplateResponse(\"tools/split.html\", {\"request\": request})\n> \n> @router.get(\"/tools/compress\", response_class=HTMLResponse)\n> async def tool_compress(request: Request):\n> return templates.TemplateResponse(\"tools/compress.html\", {\"request\": request})\n> \n> @router.get(\"/tools/pdf-to-images\", response_class=HTMLResponse)\n> async def tool_pdf_to_images(request: Request):\n> return templates.TemplateResponse(\"tools/pdf_to_images.html\", {\"request\": request})\n> \n> @router.get(\"/tools/images-to-pdf\", response_class=HTMLResponse)\n> async def tool_images_to_pdf(request: Request):\n> return templates.TemplateResponse(\"tools/images_to_pdf.html\", {\"request\": request})\n> \n> @router.get(\"/tools/extract-text\", response_class=HTMLResponse)\n> async def tool_extract_text(request: Request):\n> return templates.TemplateResponse(\"tools/extract_text.html\", {\"request\": request})\n> \n> \n> 6) Ajuste os href da Home para bater exatamente com essas rotas (/tools/merge, /tools/split, /tools/compress, /tools/pdf-to-images, /tools/images-to-pdf, /tools/extract-text).\n> \n> 7) Crie /healthz retornando 200 para teste rápido.\n> \n> 8) Mostre no console os LOGS de erro atuais se ainda der 500, para eu ver a stacktrace.\n> \n> 9) Observação de segurança: mantenha o TrustedHostMiddleware com o host do Replit permitido; cookies JWT como HttpOnly, Secure, SameSite=Lax; e certifique-se de que nenhuma rota HTML é renderizada sem {\"request\": request}.\n>