Consertar CSRF e cookie anon_id

Simplifique o CSRF para não depender do anon_id. Edite app/utils/csrf.py para:

# app/utils/csrf.py
import time, os
from itsdangerous import URLSafeSerializer, BadSignature

CSRF_SECRET = os.getenv("CSRF_SECRET", "dev-csrf-secret-change-me")
s = URLSafeSerializer(CSRF_SECRET, salt="csrf-v1")

def generate_csrf_token() -> str:
    return s.dumps({"ts": int(time.time())})

def validate_csrf_token(token: str, max_age_seconds: int = 7200) -> bool:
    try:
        data = s.loads(token)
    except BadSignature:
        return False
    return (int(time.time()) - int(data.get("ts", 0))) <= max_age_seconds


Garanta o cookie anon_id (para o modo visitante), mas não o use mais no CSRF. Em register_page e login_page, se não existir, crie:

import uuid
from fastapi import Request
from fastapi.responses import HTMLResponse
from app.utils.csrf import generate_csrf_token
from app.template_helpers import templates

def ensure_anon_cookie(request, response):
    if not request.cookies.get("anon_id"):
        response.set_cookie(
            "anon_id", str(uuid.uuid4()),
            httponly=True, secure=True, samesite="Lax", path="/"
        )

@router.get("/auth/register", response_class=HTMLResponse)
async def register_page(request: Request):
    csrf_token = generate_csrf_token()
    resp = templates.TemplateResponse("auth/register.html", {"request": request, "csrf_token": csrf_token})
    ensure_anon_cookie(request, resp)
    return resp

@router.get("/auth/login", response_class=HTMLResponse)
async def login_page(request: Request):
    csrf_token = generate_csrf_token()
    resp = templates.TemplateResponse("auth/login.html", {"request": request, "csrf_token": csrf_token})
    ensure_anon_cookie(request, resp)
    return resp


Valide o token no POST com o mesmo nome csrf_token:

from fastapi import Form, HTTPException
from app.utils.csrf import validate_csrf_token

@router.post("/auth/register")
async def register_post(
    request: Request,
    name: str = Form(...),
    email: EmailStr = Form(...),
    password: str = Form(...),
    confirm_password: str = Form(...),
    csrf_token: str = Form(...)
):
    if not validate_csrf_token(csrf_token):
        raise HTTPException(status_code=400, detail="CSRF token missing or invalid")
    # resto da lógica...

@router.post("/auth/login")
async def login_post(
    request: Request,
    email: EmailStr = Form(...),
    password: str = Form(...),
    csrf_token: str = Form(...)
):
    if not validate_csrf_token(csrf_token):
        raise HTTPException(status_code=400, detail="CSRF token missing or invalid")
    # resto da lógica...


Templates de login/registro: confirme que o form é POST para as rotas certas e contém o campo oculto csrf_token:

<form method="post" action="/auth/register">
  <input type="hidden" name="csrf_token" value="{{ csrf_token }}">
  <!-- name, email, password, confirm_password... -->
</form>

<form method="post" action="/auth/login">
  <input type="hidden" name="csrf_token" value="{{ csrf_token }}">
  <!-- email, password -->
</form>


Sempre enviar formulários como application/x-www-form-urlencoded (form padrão) ou multipart/form-data (se tiver upload). Não envie JSON em /auth/*.

Em todas as TemplateResponse(...), inclua {"request": request}.

Reinicie e me mostre os logs se persistir algum erro.