Você é um desenvolvedor sênior. Ajuste o projeto HubPDF (FastAPI + Jinja2 + HTMX + Tailwind) para ficar estável, seguro e com UI moderna e suave. A base já existe (rotas, templates e arquivos estáticos). Aplique as mudanças abaixo com testes.

1) Bugs de CSRF — corrigir 403 nos POST
1.1 Middleware (FastAPI)

Ative/ajuste o CSRFMiddleware (double-submit cookie) com cookie não-HttpOnly (o front lê o token) e Path="/".

# main.py
from app.csrf import CSRFMiddleware
from app.config import settings

app.add_middleware(
    CSRFMiddleware,
    secret=settings.CSRF_SECRET,
    cookie_name="csrf_token",
    header_name="X-CSRF-Token",
    same_site="lax",
    secure=not settings.DEBUG,
    http_only=False,         # necessário porque o front lê o cookie
)


Se UI e API estiverem em domínios diferentes, habilite CORS correto:

from fastapi.middleware.cors import CORSMiddleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=[settings.FRONT_ORIGIN],  # ex: https://hubpdf.app
    allow_credentials=True,
    allow_methods=["GET","POST","PUT","DELETE","OPTIONS"],
    allow_headers=["*"],
)

1.2 Token no HTML e no JS

Em base.html:

<meta name="csrf-token" content="{{ request.cookies.get('csrf_token') or '' }}">
<script>
  // HTMX: envia o token em todo request
  document.addEventListener("htmx:configRequest", (evt) => {
    const t = document.querySelector('meta[name="csrf-token"]')?.content;
    if (t) evt.detail.headers['X-CSRF-Token'] = t;
  });
</script>


Forms HTML clássicos: adicione

<input type="hidden" name="csrf_token" value="{{ request.cookies.get('csrf_token') }}">


HTMX nos formulários que fazem upload:

<form
  hx-post="/tools/api/convert"
  hx-encoding="multipart/form-data"
  hx-target="#job-panel"
  hx-swap="innerHTML"
  hx-credentials="true"
>
  <input type="hidden" name="csrf_token" value="{{ request.cookies.get('csrf_token') }}">
  ...
</form>


app.js (garantia extra): se o <meta> vier vazio no 1º load, leia o cookie e preencha:

(function syncCsrfMeta(){
  const m = document.querySelector('meta[name="csrf-token"]');
  if (m && !m.content) {
    const match = document.cookie.match(/(?:^|;\s*)csrf_token=([^;]+)/);
    if (match) m.content = decodeURIComponent(match[1]);
  }
})();


Critério de aceite CSRF: todo POST /tools/api/convert retorna 200/202; DevTools mostra envio do cookie e do header X-CSRF-Token.

2) Conversões — implementar/estabilizar serviço e rotas
2.1 Dependências/Replit (Nix)

Instale binários para alta fidelidade:

libreoffice, poppler, ghostscript, imagemagick, icoutils

Python (requirements/pyproject):

fastapi, uvicorn, python-multipart, pydantic-settings, sqlalchemy

PyMuPDF (fitz), pikepdf, Pillow, pdfminer.six

python-docx, python-pptx, openpyxl

passlib[bcrypt], itsdangerous, python-dateutil

2.2 Serviço de conversão (novo arquivo app/services/conversion.py)

Implemente com try/except robusto, timeouts e arquivos em /tmp (limpeza por TTL já existente):

class ConversionService:
    def pdf_to_docx(self, pdf): ...
    def docx_to_pdf(self, docx): ...
    def pdf_to_xlsx(self, pdf): ...
    def xlsx_to_pdf(self, xlsx): ...
    def pdf_to_pptx(self, pdf): ...
    def pptx_to_pdf(self, pptx): ...
    def pdf_to_images(self, pdf, fmt="png", dpi=200) -> list[str]: ...
    def images_to_pdf(self, images: list[str]) -> str: ...
    def pdf_to_txt(self, pdf) -> str: ...
    def split_pdf(self, pdf, ranges: str) -> list[str]: ...
    def compress_pdf(self, pdf, level="normal") -> str: ...
    def pdf_to_ico(self, pdf, dpi=256) -> str: ...  # rasteriza 1ª página e gera ICO multi-tamanho


Office ↔ PDF: use subprocess.run(["soffice","--headless","--convert-to", ...]) com timeout e checagem de returncode.

PDF ↔ Imagem: PyMuPDF para render (PNG/JPG/JPEG), Pillow para ICO (multi-size 16/32/48/64/128/256).

TXT: page.get_text("text") (PyMuPDF), com fallback pdfminer.six.

Split: copiar páginas (PyMuPDF/pikepdf).

Compress: pikepdf.open(...).save(..., optimize_streams=True), downscale de imagens grandes (Pillow) quando level="strong".

Validação: checar MIME real (python-magic se disponível) e extensões suportadas.

2.3 API/Jobs

POST /tools/api/convert (multipart): operation, target?, options? (json), files[] → cria job com BackgroundTasks e retorna { job_id }.

GET /tools/api/jobs/{job_id} → { status, progress, results }.

GET /tools/api/jobs/{job_id}/download/{i} → stream do arquivo.

Quota/Rate: verifique limites por plano e tamanho antes de enfileirar (usar models já existentes).

Erros: padrão {code, message, details} e log estruturado com id de job.

Critério de aceite conversões: PDF↔DOCX/XLSX/PPTX, PDF↔(PNG/JPG/JPEG/ICO), PDF→TXT, split e compress funcionam com arquivos de amostra (<= 5 MB no plano free).

3) UI/UX — paleta profissional suave + acessibilidade
3.1 Tendência para micro-SaaS 2025

Neutros claros (Slate/Stone) + uma cor de realce suave (Teal/Emerald/Indigo)

Sombras leves, bordas discretas, cantos arredondados (~12-16px)

Contraste AA, foco visível, botões com hierarquia clara (primary / outline / ghost)

3.2 Paletas sugeridas (escolha 1 como padrão e deixe variável)

Teal & Slate (default):

bg #f8fafc, text #0f172a, primary #14b8a6, primary-hover #0ea5a8, accent #6366f1

Indigo & Cyan:

bg #f7f9fb, text #0b1324, primary #6366f1, hover #5458e0, accent #06b6d4

Emerald & Slate:

bg #f8fafc, text #0f172a, primary #10b981, hover #0ea371, accent #60a5fa

3.3 Variáveis CSS e componentes (adicione no base.html ou custom.css)
:root{
  --bg:#f8fafc; --card:#ffffff; --text:#0f172a; --muted:#64748b;
  --primary:#14b8a6; --primary-600:#0ea5a8; --accent:#6366f1;
  --ring:0 0 0 3px rgba(20,184,166,.25);
}

body{ background:var(--bg); color:var(--text); }
.modern-card{ border:1px solid #e2e8f0; border-radius:16px; background:var(--card); box-shadow:0 1px 2px rgba(0,0,0,.04); }

.btn{ display:inline-flex; align-items:center; gap:.5rem; padding:.6rem 1rem; border-radius:12px; font-weight:500; transition:.15s; }
.btn-primary{ background:var(--primary); color:#fff; }
.btn-primary:hover{ background:var(--primary-600); }
.btn-outline{ background:#fff; color:#0f172a; border:1px solid #cbd5e1; }
.btn-outline:hover{ background:#f1f5f9; }
.btn-ghost{ color:#334155; }
.btn-ghost:hover{ background:#f1f5f9; }

.form-input,.form-select{ width:100%; border:1px solid #cbd5e1; border-radius:12px; padding:.55rem .8rem; }
.form-input:focus,.form-select:focus{ outline:none; box-shadow:var(--ring); border-color:#94e0d8; }

.dropzone{ border:2px dashed #cbd5e1; border-radius:16px; padding:1.25rem; background:#ffffffa6; text-align:center; }
.dropzone.dragover{ border-color:var(--primary); background:#ecfeff; }

a:focus,button:focus,input:focus,select:focus{ box-shadow:var(--ring); outline:none; }

3.4 Harmonizar ícones e PWA

Renderizar Lucide no load e após respostas HTMX:

<script>
  document.addEventListener('DOMContentLoaded', ()=>{ if (window.lucide) lucide.createIcons(); });
  document.addEventListener('htmx:afterSwap', ()=>{ if (window.lucide) lucide.createIcons(); });
</script>


manifest.json:
theme_color = cor primária escolhida (ex.: #14b8a6) e background_color = #ffffff.

service-worker.js: aumente CACHE_NAME (ex.: hubpdf-v1.0.2) para forçar baixar o CSS novo.

Critérios UI: contraste AA (botões e texto), foco visível, botões principais destacados mas suaves; ícones Lucide renderizam sempre (SSR e após HTMX).

4) Testes e verificação manual
4.1 Unit

Testar cada método do ConversionService com PDFs/Docs/Imagens pequenos (fixtures no repositório).

Simular timeouts/falhas (soffice indisponível) e verificar mensagens de erro padronizadas.

4.2 E2E

Fluxo: GET /tools/ → POST /tools/api/convert (PDF→DOCX, PDF→PNG, Images→PDF, PDF→TXT, Split, Compress) → GET /tools/api/jobs/{id} até done → downloads.

Validar CSRF ok (sem 403), limites por tamanho, e limpeza de temporários.

5) Entregáveis

Código atualizado com as mudanças acima.

README com instruções (Replit/Nix, variáveis .env, limites free/pro).

Lista de checagem marcada (CSRF, CORS, conversões, UI, PWA cache bump).

Testes passando no CI do Replit.

6) Observações de segurança/perf

Sanitizar nomes/paths e validar MIME real; bloquear PDFs com JavaScript embutido.

Timeouts e kill de processos soffice travados.

Rate-limit/quotas antes de enfileirar jobs.

Limpeza de /tmp por TTL (não deletar arquivos em uso; usar lockfile).

Objetivo final: app sem 403 de CSRF, com conversões estáveis e UI agradável (paleta suave), pronto para uso em produção no Replit.